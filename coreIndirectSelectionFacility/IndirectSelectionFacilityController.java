package coreIndirectSelectionFacility;

import invocationParametersISF.IndirectSelectionFacilityInvocationParameterModel;

import javax.swing.*;

import customGUIComponentsISF.JIndirectSelectionButton;

import treeDataStructure.SelectionGroup;

import buttonLayouts.ButtonLayoutSpecification;
import buttonLayouts.ButtonLayoutSpecificationGenerator;

import actionScheme.ActionScheme;
import actionScheme.ActionSchemeGenerator;

import encodingTrees.Code;
import encodingTrees.TraversableEncodingTree;

import IndirectSelectionFacility.OnScreenKeyboardView;
import IndirectSelectionFacility.PassiveFokusAdvancerSwing;
import IndirectSelectionFacilityCommands.IndirectSelectionFaciltyCommand;

import java.awt.AWTEventMulticaster;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.*;
import java.io.PrintStream;

/**
 * This class implements a controller for the indirect selection facility.
 * 
 * The controller initializes to a paused state (nothing happens).
 * 
 * What happens in response to what input actions? This is determined by the
 * particular ActionScheme that is used with this controller.
 * 
 * 
 * The user is presented with the indirect selection facility view.
 * 
 * This controller responds to various user input actions (on the basis of the
 * events generated by those actions, for which this controller listens). As
 * well, there are certain services provided so that the controller can be made
 * to effect actions programmatically.
 * 
 * If passive focus advancement is indicated (as opposed to active focus
 * advancement or directed traversal), then the controller will initiate advance
 * focus events. The controller's initial state is that the event generator is
 * initialized but not firing.
 * 
 * Once the advance focus event generator is firing, the user is afforded a
 * potentially unending interaction consisted of repeated encoding tree
 * traversals, each successful traversal results in the selection of a
 * character, which gets appended to the text gloss (exception to this are the
 * delete selectable and the pilcrow, which is mapped to a placeholder
 * "send to TTS" command).
 * 
 * There are two ways to start the events firing: (1) via the listener's
 * behaviours and (2) via method invocation.
 * 
 * wrt (2), A core service provided by this class is the
 * "lauchFocusAdvancement()" method.
 * 
 * This class provides services to traverse the encoding tree, which are
 * functions mapped to various keystrokes (implemented in the keyPressed and
 * keyReleased methods), via the input action scheme
 * 
 * 
 * @author M. Baljko, 2004
 * @param <Code>
 */
// public class IndirectSelectionFacilityController<Code> implements
// ActionListener,
// KeyListener {
public class IndirectSelectionFacilityController implements ActionListener,
		KeyListener {

	private IndirectSelectionFacilityInvocationParameterModel paramManager;
	private ActionScheme inputActionScheme = null;
	private final boolean IS_VERBOSE = false;
	private PrintStream output = System.out;
	private IndirectSelectionFacilityView view;
	private PassiveFokusAdvancerSwing fokusController;
	private EncodingTreeTraversalAndFokusController etController;

	private ActionListener actionListenerList = null;

	public IndirectSelectionFacilityController(
			IndirectSelectionFacilityView view,
			IndirectSelectionFacilityInvocationParameterModel paramManager,
			TraversableEncodingTree encodingTree) {
		this.view = view;

		this.paramManager = paramManager;

		etController = new EncodingTreeTraversalAndFokusController(view,
				encodingTree);

		ActionSchemeGenerator asg = new ActionSchemeGenerator();
		inputActionScheme = asg.createInstance(paramManager, this);
		if (this.paramManager.isWithFocusAdvancement()
				&& this.paramManager.isWithPassiveFocusAdvancement()) {
			fokusController = new PassiveFokusAdvancerSwing(this, paramManager
					.getDwellTime());
		}

		if (this.paramManager.isUsingAssistiveTechnologyMouseLikeDevice()) {
			this
					.installAssistiveTechnologyMouseLikeDeviceListener(new AssistiveTechnologyMouseLikeDeviceListener(
							this, view));
		}

		this.resetFokus();

		view.getFocusReceivingComponent().addKeyListener(this);
		view.getFocusReceivingComponent().requestFocus();
		view.addComponentListener(new MySizeChangeListener(this));

		this.resizeOptimizedComponents();

	}

	public void resizeOptimizedComponents() {
		this.getView().invalidate();
		this.getView().validate();
		this.getView().repaint();

		if (IS_VERBOSE)
			System.out.println(this.getClass().getName()
					+ " : Resizing components.");
		this.getView().getOnScreenKeyboard().resizeOptimizedComponents();

		this.getView().setCompositionAreaDisplayFontAsLargesAsPossible(
				etController.getCode().getRoot().getLeaves());

	}

	public IndirectSelectionFacilityInvocationParameterModel getParameterModel() {
		return paramManager;
	}

	public static OnScreenKeyboardView generateOnScreenKeyboardView(
			IndirectSelectionFacilityInvocationParameterModel paramModel,
			TraversableEncodingTree encodingTree) {
		OnScreenKeyboardView onScreenKeyboard = null;

		ButtonLayoutSpecificationGenerator kbg = new ButtonLayoutSpecificationGenerator();
		ButtonLayoutSpecification keyboardContainer = kbg.createInstance(
				encodingTree, paramModel);

		onScreenKeyboard = new OnScreenKeyboardView(keyboardContainer,
				paramModel);
		return onScreenKeyboard;
	}

	// public void fireActionEvent(JIndirectSelectionButton targetButton) {
	// targetButton.actionPerformed(new ActionEvent(targetButton, 0,
	// targetButton.getActionCommand()));
	// }

	// //////////////////////////////////////////////////////////////////
	// ////// ACTION LISTENER ///////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	/**
	 * Add this stuff so that listeners can be installed on this controller, and
	 * so this controller will fire ActionEvents that can be detected by
	 * observers
	 */

	public synchronized void addActionListener(ActionListener l) {
		actionListenerList = AWTEventMulticaster.add(actionListenerList, l);
	}

	public synchronized void removeActionListener(ActionListener l) {
		actionListenerList = AWTEventMulticaster.remove(actionListenerList, l);
	}

	// //////////////////////////////////////////////////////////////////
	// ////// ACTION LISTENER ///////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	/*
	 * We provide a body for this method to satisfy the requirements that this
	 * class implements the interface ActionListener. We want for this class to
	 * be an actionListener
	 */
	public synchronized void actionPerformed(ActionEvent ae) {
		// System.out.println(ae.toString());
		if (IS_VERBOSE) {
			output.println("actionPerformed on: " + toStringAbbr());
			output.println("\t ActionEvent is: " + ae.toString());
			output.println("\t action command of ActionEvent is: "
					+ ae.getActionCommand());
			output.println("\t source of ActionEvent is: " + ae.getSource());
		}
		try {
			((IndirectSelectionFaciltyCommand) ae.getSource())
					.execute(this, ae);
		} catch (Exception e) {
			System.out.println("Failure point: " + ae.toString());
			System.out.println("Failure point: "
					+ ((IndirectSelectionFaciltyCommand) ae.getSource())
							.toString());
			e.printStackTrace();
			System.exit(0);
		}
		if (actionListenerList != null) {
			actionListenerList.actionPerformed(ae);
		}
	}

	public void keyTyped(KeyEvent ke) {
	}

	public void keyPressed(KeyEvent ke) {

		ActionEvent theActionEvent = inputActionScheme.interpretKeyPress(ke,
				etController.isFokusAtRootCycle());

		if (IS_VERBOSE) {
			// if (true) {
			System.out.println(this.getClass().getName() + ": "
					+ this.getView().getTitle() + ": Key Event rec'd: "
					+ ke.getKeyCode() + "\t" + ke.getWhen());
			// System.out.println("\t"
			// + this.paramManager.isWithFocusAdvancement() + "\t"
			// + this.paramManager.isWithPassiveFocusAdvancement());
			System.out.println(this.getClass().getName()
					+ ": Action Event to be performed: " + theActionEvent);
		}
		// System.out.println(ae3);
		if (theActionEvent != null) {
			((ActionListener) this).actionPerformed(theActionEvent);
		}
	}

	public void keyReleased(KeyEvent ke) {
		ActionEvent ae3 = inputActionScheme.interpretKeyRelease(ke);
		// System.out.println(ae3);
		if (ae3 != null) {
			((ActionListener) this).actionPerformed(ae3);
		}

	}

	// /////////////////////////////////////////////////////////
	// CONCERNING FOCUS CONTROL
	// /////////////////////////////////////////////////////////

	public void launchPassiveFocusAdvancement() {
		fokusController.startEventGenerator();
	}

	public void placeFocusCorrectly() {
		etController.placeFocusCorrectly();
	}

	public void descendFokus() {
		etController.descendFokus();
		// this.getView().updateAppearance();
	}

	public void resetFokus() {
		etController.resetFokus();
		// this.getView().updateAppearance();
	}

	public void resetFokusAndClear() {
		etController.resetFokus();
		this.getView().updateAppearance();
	}

	public boolean ascendFokus() {
		return etController.ascendFokus();
	}

	public boolean isWithPassiveFocusAdvancement() {
		return paramManager.isWithPassiveFocusAdvancement();
	}

	public void shiftFokusToNextSG() {
		etController.shiftFokusToNextSG();
	}

	public void highlightCurrentSelectionGroupAsSelected() {
		etController.highlightCurrentSelectionGroupAsSelected();
	}

	public void pausePassiveFocusAdvancement() {
		fokusController.pause();
	}

	public void initToStartOfFokusCycleAndLaunch() {
		fokusController.initToStartOfFokusCycle();
	}

	public void unpausePassiveFocusAdvancement() {
		fokusController.unpause();
	}

	public void togglePassiveFocusAdvancementOnOff() {
		if (fokusController.isEventGenerationActive()) {
			fokusController.pause();
			System.out.println(this.getClass().getName()
					+ " : Focus Advancement Paused.");
		} else {
			fokusController.startEventGenerator();
			System.out.println(this.getClass().getName()
					+ " Focus Advancement Started.");
		}
	}

	public boolean isFokusAdvancementActive() {
		return fokusController.isEventGenerationActive();
	}

	// ////////////////////////////////
	// CONCERING WINDOWING
	// ////////////////////////////////

	public boolean isActive() {
		return ((JFrame) view).isActive();// grabFocus();
	}

	public void putViewToFront() {
		// ((JFrame) rsvpDisplay).requestFocusInWindow();//grabFocus();
		((JFrame) view).toFront();// grabFocus();
		view.configureForDisplay(paramManager.isFullScreen());
		view.getFocusReceivingComponent().requestFocus();
		// view.getFocusReceivingComponent().grabFocus();

	}

	// ////////////////////////////////

	// public void launchFocusAdvancement() {
	// ActionEvent ae4 = new ActionEvent(new EncodingTreePresentInitialView(),
	// 0, "");
	// ((ActionListener) this).actionPerformed(ae4);
	// }

	// public String getSubjectID() {
	// return paramManager.getUserId();
	// }

	// /////////////////////////////////////////////////////////
	// OTHER
	// /////////////////////////////////////////////////////////

	public String toStringAbbr() {
		String tmp = this.toString();
		if (tmp.indexOf("[") != -1) {
			return tmp.substring(0, tmp.indexOf("["));
		} else
			return tmp;
	}

	public IndirectSelectionFacilityView getView() {
		return view;
	}

	public void appendToGloss(String charToAppend) {
		this.getView().getCompositionWidget().augmentGloss(charToAppend);
	}

	public String getTextGloss() {
		return this.getView().getCompositionWidget().getTheText();
	}
	
	public String getMostRecentlyAppended() {
		return this.getView().getCompositionWidget().getMostRecentlyAppended();
	}


	public void putCurrentSelectionGroupInFocus() {
		etController.putCurrentSelectionGroupInFocus();
		this.getView().updateAppearance();
	}

	public String getFokusTimerStatus() {
		return etController.getFokusTimerStatus();
	}

	public int getDurationOfTimeCurrentFocusGroupHasBeenInFocus() {
		return etController.getDurationOfTimeCurrentFocusGroupHasBeenInFocus();
	}

	public String getFokusTimerStatusForCurrentSelectionGroup() {
		return etController.getFokusTimerStatusForCurrentSelectionGroup();
	}

	public boolean isCurrentSelectionGroupTrivial() {
		return etController.isCurrentSelectionGroupTrivial();

	}

	public IndirectSelectionFaciltyCommand getCurrentISFCommand() {
		return etController.getCurrentISFCommand();
	}

	public void stopFocusAdvancement() {
		fokusController.pause();
	}

	public void makeViewEmptyAndResetGloss() {
		view.makeEntireDisplayEmptyAndResetGloss();
	}

	public Code getCode() {
		return etController.getCode();
	}

	public void installAssistiveTechnologyMouseLikeDeviceListener(
			MouseListener mouseListener) {
		view.getGlassPane().setVisible(true);
		view.getGlassPane().addMouseListener(mouseListener);
	}

	public void repositionCaret(int newPosition) {
		view.repositionCaret(newPosition);
	}

	public String getRandomlySelectedSymbol() {
		return etController.getRandomlySelectedSymbol();
	}

	public void clearGloss() {
		view.clearGloss();
	}

	public boolean shouldAutomaticallyReinitializeFokusAfterCompleteTraversal() {
		return inputActionScheme
				.shouldAutomaticallyReinitializeFokusAfterCompleteTraversal();
	}

	public boolean shouldAutomaticallyReinitializeGlossAfterCompleteTraversal() {
		return inputActionScheme
				.shouldAutomaticallyReinitializeGlossAfterCompleteTraversal();
	}

	public SelectionGroup getCurrentSelectionGroup() {
		return etController.getCurrentSelectionGroup();
	}

	public void toggleCapsOnOff() {
		etController.toggleCapsOnOff();
	}

	public void toggleCapsOn() {
		etController.toggleCapsOn();
	}

	public void toggleCapsOff() {
		etController.toggleCapsOff();
	}

	public boolean shouldToggleCapsOn() {
		// source symbols are initialized to On, toggle off in the following
		// situations
		// 1. first character has just been appended
		// 2. first character after a period has been appended
		boolean isFirstCharOfGlossOnly = getTextGloss().length() == 0;
		boolean isMostRecentCharAPeriod = false;
		if (!isFirstCharOfGlossOnly && getTextGloss().length() >= 2) {
			// kludge - periods get a space appended afterwards
			isMostRecentCharAPeriod = getTextGloss().substring(
					getTextGloss().length() - 2, getTextGloss().length())
					.equals(JIndirectSelectionButton.VK_PERIOD.getText() + " ");
		}
		// System.out.println(this.getClass().getName()
		// + " : should toggle caps? " + isFirstCharOfGlossOnly + "\t"
		// + isMostRecentCharAPeriod);
		return isFirstCharOfGlossOnly || isMostRecentCharAPeriod;
	}

	public boolean shouldToggleCapsOff() {
		return true;
	}

	public TraversableEncodingTree getEncodingTree() {
		return etController.getEncodingTree();
	}
}
